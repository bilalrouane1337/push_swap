===== checker.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checker.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/31 20:50:46 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:50:47 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "checker.h"

typedef struct s_data
{
	char	**array;
	long	*original_numbers;
	long	*sorted_numbers;
	int		count;
}	t_data;

/* ------------------------------------------------------------ */

static int	is_sorted_stack(t_stack_node *stack)
{
	if (!stack)
		return (1);
	while (stack->next)
	{
		if (stack->index > stack->next->index)
			return (0);
		stack = stack->next;
	}
	return (1);
}

/* ------------------------------------------------------------ */

static int	exec_instruction(char *line,
			t_stack_node **a, t_stack_node **b)
{
	if (!ft_strcmp(line, "sa\n"))
		sa(a, 0);
	else if (!ft_strcmp(line, "sb\n"))
		sb(b, 0);
	else if (!ft_strcmp(line, "ss\n"))
		ss(a, b, 0);
	else if (!ft_strcmp(line, "pa\n"))
		pa(a, b, *b, 0);
	else if (!ft_strcmp(line, "pb\n"))
		pb(a, b, *a, 0);
	else if (!ft_strcmp(line, "ra\n"))
		ra(a, 0);
	else if (!ft_strcmp(line, "rb\n"))
		rb(b, 0);
	else if (!ft_strcmp(line, "rr\n"))
		rr(a, b, 0);
	else if (!ft_strcmp(line, "rra\n"))
		rra(a, 0);
	else if (!ft_strcmp(line, "rrb\n"))
		rrb(b, 0);
	else if (!ft_strcmp(line, "rrr\n"))
		rrr(a, b, 0);
	else
		return (0);
	return (1);
}

/* ------------------------------------------------------------ */

static int	read_and_execute(t_stack_node **a, t_stack_node **b)
{
	char	*line;

	while ((line = get_next_line(0)))
	{
		if (!exec_instruction(line, a, b))
		{
			free(line);
			return (0);
		}
		free(line);
	}
	return (1);
}

/* ------------------------------------------------------------ */

static int	checker(int argc, char **argv)
{
	t_stack_node	*stack_a;
	t_stack_node	*stack_b;
	t_data			data;

	if (initialize_data(argc, argv, &data))
		return (1);

	stack_a = NULL;
	stack_b = NULL;

	if (sort_numbers(data.sorted_numbers, data.count)
		|| assign_to_stack(&stack_a,
			data.original_numbers,
			data.sorted_numbers,
			data.count))
	{
		free_all_stacks(&stack_a, &stack_b);
		free_pointers(data.array,
			&data.sorted_numbers,
			&data.original_numbers,
			data.count);
		return (1);
	}

	if (!read_and_execute(&stack_a, &stack_b))
	{
		write(2, "Error\n", 6);
		free_all_stacks(&stack_a, &stack_b);
		free_pointers(data.array,
			&data.sorted_numbers,
			&data.original_numbers,
			data.count);
		return (1);
	}

	if (is_sorted_stack(stack_a) && !stack_b)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);

	free_all_stacks(&stack_a, &stack_b);
	free_pointers(data.array,
		&data.sorted_numbers,
		&data.original_numbers,
		data.count);
	return (0);
}

/* ------------------------------------------------------------ */

int	main(int argc, char **argv)
{
	return (checker(argc, argv));
}

===== error_checker.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error_checker.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/24 16:51:59 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 21:46:42 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	ft_isdigit(char d)
{
	if (d >= 48 && 57 >= d)
		return (1);
	return (0);
}

int	ft_issign(char s)
{
	if (s == 43 || s == 45)
		return (1);
	return (0);
}

int	dig_sign_checker(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (!(ft_isdigit(str[i]) || ft_issign(str[i])))
			return (1);
		if (ft_issign(str[i]) && (i != 0
				|| (i == 0 && ft_strlen(str) == 1)))
			return (1);
		i++;
	}
	return (0);
}

int	dup_errors(int count, long *original_numbers)
{
	int	i;
	int	j;

	i = 0;
	while (count > i)
	{
		j = 0;
		while (count > j)
		{
			if (original_numbers[i] == original_numbers[j] && i != j)
				return (1);
			j++;
		}
		i++;
	}
	return (0);
}

int	check_for_errors(char ***array, long **original_numbers, int count)
{
	int	max;
	int	flag;

	max = 0;
	flag = 0;
	while ((*array)[max])
	{
		if (dig_sign_checker((*array)[max]))
		{
			flag = 1;
			break ;
		}
		(*original_numbers)[max] = ft_atoi((*array)[max], &flag);
		if (flag == 1)
			break;
		max++;
	}
	if (flag == 0)
	{
		if (dup_errors(count, *original_numbers))
			return (ft_print("Error"), 1);
	}
	else
		return (ft_print("Error"), 1);
	return (0);
}

===== extended_functions.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   extended_functions.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 17:19:53 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 22:10:20 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	assign_to_stack(t_stack_node **stack, long *original_numbers,
		long *sorted_numbers, int count)
{
	int	i;
	int	index;

	i = 0;
	while (i < count)
	{
		index = find_index(original_numbers[i], sorted_numbers, count);
		if (ft_lstadd_back(stack, original_numbers[i], index))
			return (1);
		i++;
	}
	return (0);
}

===== external_functions.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   external_functions.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/10 19:51:51 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 22:36:11 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	ft_count_words(char const *str, char c)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (str[i] != '\0')
	{
		if (str[i] == c)
			i++;
		else
		{
			count++;
			while (str[i] && str[i] != c)
				i++;
		}
	}
	return (count);
}

int	find_index(int value, long *sorted_numbers, int c)
{
	int	index;

	index = 0;
	while (c > index)
	{
		if (value == sorted_numbers[index])
			break;
		index++;
	}
	return (index);
}

size_t	ft_strlen(const char *s)
{
	size_t	len;

	len = 0;
	while (s[len])
		len++;
	return (len);
}

===== freedom.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   freedom.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/07 18:28:25 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 21:52:15 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	free_array(char **ptr, int i)
{
	while (i > 0)
	{
		i--;
		free(ptr[i]);
	}
	free(ptr);
	return (-1);
}

void	free_pointers(char **array, long **sorted_numbers, long **original_numbers,
			int len)
{
	free_array(array, len);
	free(*sorted_numbers);
	free(*original_numbers);
}

void	free_stack(t_stack_node **stack)
{
	t_stack_node	*temp;

	if (!stack)
		return ;
	temp = *stack;
	while (*stack)
	{
		temp = (*stack)->next;
		free(*stack);
		*stack = temp;
	}
}

void	free_all_stacks(t_stack_node **stack_a, t_stack_node **stack_b)
{
	free_stack(stack_a);
	free_stack(stack_b);
}

===== ft_atoi.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/18 18:56:22 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 21:40:08 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	ft_atoi(const char *nptr, int *flag)
{
	size_t	i;
	long	result;
	int	sign;

	i = 0;
	result = 0;
	sign = 1;
	if (nptr[i] == '+' || nptr[i] == '-')
	{
		if (nptr[i] == '-')
			sign = -1;
		i++;
	}
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + (nptr[i] - '0');
		if (result * sign > INT_MAX || result * sign < INT_MIN)
		{
			*flag = 1;
			break;
		}
		i++;
	}
	return ((int)result * sign);
}

===== ft_lstadd_back.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/21 18:37:28 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 22:22:47 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

t_stack_node	*ft_lstnew(long value, int index)
{
	t_stack_node	*node;

	node = (t_stack_node *)malloc(sizeof(t_stack_node));
	if (!node)
		return (NULL);
	node->value = value;
	node->index = index;
	node->next = NULL;
	return (node);
}

int	ft_lstadd_back(t_stack_node **lst, long value, int index)
{
	t_stack_node	*start;
	t_stack_node	*new;

	new = ft_lstnew(value, index);
	if (new == NULL)
		return (1);
	if (*lst)
	{
		start = *lst;
		while (start->next)
			start = start->next;
		start->next = new;
	}
	else
		*lst = new;
	return (0);
}

===== ft_print.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_print.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/07 22:10:09 by brouane           #+#    #+#             */
/*   Updated: 2026/01/20 16:59:46 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	ft_print(char *str)
{
	while (*str)
	{
		write(1, str, 1);
		str++;
	}
	write(1, "\n", 1);
}

===== get_next_line.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 11:39:09 by brouane          #+#    #+#             */
/*   Updated: 2025/12/07 16:19:26 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

char	*next_line(char *working_line)
{
	char	*line;
	int		i;
	int		add;

	i = 0;
	add = 1;
	if (!working_line || working_line[i] == '\0')
		return (NULL);
	while (working_line[i] && working_line[i] != '\n')
		i++;
	if (working_line[i] == '\n')
		add = 2;
	line = (char *)malloc(sizeof(char) * (i + add));
	if (!line)
		return (NULL);
	i = -1;
	while (working_line[++i] && working_line[i] != '\n')
		line[i] = working_line[i];
	if (working_line[i] == '\n')
		line[i++] = '\n';
	line[i] = '\0';
	return (line);
}

char	*read_line(char *working_line, int fd)
{
	char		*buffer;
	ssize_t		readen;

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	readen = 1;
	buffer = (char *)malloc(sizeof(char) * BUFFER_SIZE + 1);
	if (!buffer)
		return (NULL);
	while (readen > 0 && ft_strchr(working_line))
	{
		readen = read(fd, buffer, BUFFER_SIZE);
		if (readen == -1)
			return (free(buffer), NULL);
		buffer[readen] = '\0';
		working_line = ft_strjoin(working_line, buffer);
	}
	free(buffer);
	return (working_line);
}

char	*new_line(char *working_line)
{
	int		i;
	int		j;
	char	*new_working_line;

	i = 0;
	while (working_line[i] && working_line[i] != '\n')
		i++;
	if (!working_line[i])
		return (free(working_line), NULL);
	new_working_line = (char *)malloc((ft_strlen(working_line) - i++));
	if (!new_working_line)
		return (NULL);
	j = 0;
	while (working_line[i])
		new_working_line[j++] = working_line[i++];
	new_working_line[j] = '\0';
	free(working_line);
	return (new_working_line);
}

char	*get_next_line(int fd)
{
	static char	*working_line;
	char		*line;

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	working_line = read_line(working_line, fd);
	if (!working_line)
		return (NULL);
	line = next_line(working_line);
	working_line = new_line(working_line);
	if (working_line && !*working_line)
	{
		free(working_line);
		working_line = NULL;
	}
	return (line);
}

===== get_next_line_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 11:41:08 by brouane          #+#    #+#             */
/*   Updated: 2025/12/04 17:52:12 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "get_next_line.h"

size_t	ft_strlen(const char *str)
{
	size_t	len;

	len = 0;
	while (str[len])
		len++;
	return (len);
}

int	ft_strchr(char *working_line)
{
	int	i;

	i = 0;
	while (working_line && working_line[i])
	{
		if (working_line[i] == '\n')
			return (0);
		i++;
	}
	return (1);
}

char	*ft_strjoin_copy(char *joined, char *working_line, char *buffer)
{
	int	i;
	int	j;

	i = 0;
	while (working_line[i])
	{
		joined[i] = working_line[i];
		i++;
	}
	j = 0;
	while (buffer[j])
		joined[i++] = buffer[j++];
	joined[i] = '\0';
	return (joined);
}

char	*ft_strjoin(char *working_line, char *buffer)
{
	char	*joined;

	if (!buffer)
		return (NULL);
	if (!working_line)
	{
		working_line = malloc(sizeof(char));
		if (!working_line)
			return (NULL);
		working_line[0] = '\0';
	}
	joined = malloc((ft_strlen(working_line) + ft_strlen(buffer) + 1));
	if (!joined)
		return (free(working_line), NULL);
	ft_strjoin_copy(joined, working_line, buffer);
	return (free(working_line), joined);
}

===== internal_functions.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   internal_functions.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 15:02:43 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 22:19:45 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	count_all_nums(char **argv, int argc)
{
	int	i;
	int	count;
	int	holder;

	i = 0;
	count = 0;
	while (i < argc - 1)
	{
		holder = ft_count_words(argv[i], 32);
		if (holder == 0)
		{
			ft_print("Error");
			exit(1);
		}
		count += holder;
		i++;
	}
	return (count);
}

char	**array_manager(char **argv, int argc, int count)
{
	int		i;
	char	**array;
	int		index_reached;

	index_reached = 0;
	array = (char **)malloc(sizeof(char *) * (count + 1));
	if (!array)
		exit(1);
	i = 0;
	while (i < argc - 1)
	{
		index_reached = split_them(argv[i++], &array, index_reached);
		if (index_reached == -1)
			exit(1);
	}
	return (array);
}

void	numbers_manager(char ***array, int count, long **sorted_numbers,
			long **original_numbers)
{
	*sorted_numbers = (long *)malloc(sizeof(long) * count);
	*original_numbers = (long *)malloc(sizeof(long) * count);
	if (!*sorted_numbers || !*original_numbers)
	{
		free_pointers(*array, sorted_numbers, original_numbers, count);
		exit(1);
	}
}

void	numbers_copy(long *sorted_numbers, long *original_numbers, int count)
{
	int	i;

	i = 0;
	while (i < count)
	{
		sorted_numbers[i] = original_numbers[i];
		i++;
	}
}

int	sort_numbers(long *sorted_numbers, int c)
{
	int		i;
	int		j;
	int		flag;
	long	temp;

	flag = 1;
	i = 0;
	while (i < c - 1)
	{
		j = i + 1;
		while (j <= c - 1)
		{
			if (sorted_numbers[i] > sorted_numbers[j])
			{
				temp = sorted_numbers[i];
				sorted_numbers[i] = sorted_numbers[j];
				sorted_numbers[j] = temp;
				flag = 0;
			}
			j++;
		}
		i++;
	}
	return (flag);
}

===== operations_manager.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operations_manager.count                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 15:12:21 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 22:24:50 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	two_sorter(t_stack_node **stack_a)
{
	ra(stack_a, 1);
}

void	five_sorter(t_stack_node **stack_a, t_stack_node **stack_b, int count)
{
	push_from_a(stack_a, stack_b, count);
	three_sorter(stack_a);
	push_back_to_a(stack_a, stack_b, count - 3);
}

void	chunk_sorter(t_stack_node **stack_a, t_stack_node **stack_b, int count)
{
	push_to_b(stack_a, stack_b, count);
	push_back_to_a(stack_a, stack_b, count);
}

void	operations_manager(t_stack_node **stack_a, t_stack_node **stack_b,
	int count)
{
	if (count == 2)
		two_sorter(stack_a);
	else if (count == 3)
		three_sorter(stack_a);
	else if (count <= 5)
		five_sorter(stack_a, stack_b, count);
	else
		chunk_sorter(stack_a, stack_b, count);
}

===== push_back_to_a.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_back_to_a.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 15:15:27 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:18:40 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	which_position(t_stack_node *stack, int real_len)
{
	int	pos;

	pos = 0;
	while (stack && stack->index != real_len)
	{
		stack = stack->next;
		pos++;
	}
	return (pos);
}

void	push_using_rb(t_stack_node **stack_a, t_stack_node **stack_b,
		int *position, int *real_len)
{
	while (*stack_b && *position > 0)
	{
		rb(stack_b, 1);
		(*position)--;
	}
	if (*stack_b)
	{
		pa(stack_a, stack_b, *stack_b, 1);
		(*real_len)--;
	}
}

void	push_using_rrb(t_stack_node **stack_a, t_stack_node **stack_b,
		int *position, int *real_len)
{
	while (*stack_b && *position <= *real_len)
	{
		rrb(stack_b, 1);
		(*position)++;
	}
	if (*stack_b)
	{
		pa(stack_a, stack_b, *stack_b, 1);
		(*real_len)--;
	}
}

void	push_back_to_a(t_stack_node **stack_a, t_stack_node **stack_b, int c)
{
	int	real_len;
	int	position;

	real_len = c - 1;
	while (*stack_b)
	{
		if ((*stack_b)->index == real_len)
		{
			pa(stack_a, stack_b, *stack_b, 1);
			real_len--;
		}
		else
		{
			position = which_position(*stack_b, real_len);
			if (position < real_len / 2)
				push_using_rb(stack_a, stack_b, &position, &real_len);
			else
				push_using_rrb(stack_a, stack_b, &position, &real_len);
		}
	}
}

===== push.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 17:03:00 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:13:49 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	push(t_stack_node **from_stack,
		t_stack_node **to_stack, t_stack_node *to_push)
{
	if (from_stack && to_stack && *from_stack)
	{
		*from_stack = to_push->next;
		to_push->next = *to_stack;
		*to_stack = to_push;
	}
}

void	pb(t_stack_node **stack_a, t_stack_node **stack_b,
		t_stack_node *to_push, int to_print)
{
	if(to_print)
		ft_print("pb");
	push(stack_a, stack_b, to_push);
}

void	pa(t_stack_node **stack_a, t_stack_node **stack_b,
		t_stack_node *to_push, int to_print)
{
	if(to_print)
		ft_print("pa");
	push(stack_b, stack_a, to_push);
}

===== push_from_a.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_from_a.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 16:37:28 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:18:18 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	which_position_in_a(t_stack_node *stack, int real_len)
{
	int	pos;

	pos = 0;
	while (stack && stack->index != real_len)
	{
		stack = stack->next;
		pos++;
	}
	return (pos);
}

void	push_using_ra(t_stack_node **stack_a, t_stack_node **stack_b,
		int *position, int *real_len)
{
	while (*stack_a && *position > 0)
	{
		ra(stack_a, 1);
		(*position)--;
	}
	if (*stack_a)
	{
		pb(stack_a, stack_b, *stack_a, 1);
		(*real_len)--;
	}
}

void	push_using_rra(t_stack_node **stack_a, t_stack_node **stack_b,
		int *position, int *real_len)
{
	while (*stack_a && *position <= *real_len)
	{
		rra(stack_a, 1);
		(*position)++;
	}
	if (*stack_a)
	{
		pb(stack_a, stack_b, *stack_a, 1);
		(*real_len)--;
	}
}

void	push_from_a(t_stack_node **stack_a, t_stack_node **stack_b, int c)
{
	int	min_index;
	int	max_index;
	int	position;
	int	right_len;

	min_index = 0;
	max_index = c - 3;
	right_len = c - 1;
	while (*stack_a && min_index < max_index)
	{
		if ((*stack_a)->index == min_index)
		{
			pb(stack_a, stack_b, *stack_a, 1);
			right_len--;
		}
		else
		{
			position = which_position_in_a(*stack_a, min_index);
			if (position <= right_len / 2)
				push_using_ra(stack_a, stack_b, &position, &right_len);
			else
				push_using_rra(stack_a, stack_b, &position, &right_len);
		}
		min_index++;
	}
}

===== push_swap.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/24 16:53:12 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:57:34 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	initialize_data(int argc, char **argv, t_data *data)
{
	if (argc == 1)
		return (1);
	data->count = count_all_nums(argv + 1, argc);
	data->array = array_manager(argv + 1, argc, data->count);
	numbers_manager(&data->array, data->count,
		&data->sorted_numbers, &data->original_numbers);
	if (check_for_errors(&data->array,
			&data->original_numbers, data->count))
		return (free_pointers(data->array,
				&data->sorted_numbers, &data->original_numbers,
				data->count), 1);
	numbers_copy(data->sorted_numbers, data->original_numbers, data->count);
	return (0);
}

int	push_swap(int argc, char **argv)
{
	t_stack_node	*stack_a;
	t_stack_node	*stack_b;
	t_data			data;

	if (initialize_data(argc, argv, &data))
		return (1);
	stack_a = NULL;
	stack_b = NULL;
	if (sort_numbers(data.sorted_numbers, data.count)
		|| assign_to_stack(&stack_a,
			data.original_numbers, data.sorted_numbers, data.count))
	{
		free_all_stacks(&stack_a, &stack_b);
		free_pointers(data.array, &data.sorted_numbers,
			&data.original_numbers, data.count);
		return (1);
	}
	operations_manager(&stack_a, &stack_b, data.count);
	
	t_stack_node *tm = stack_a;
	while (tm)
	{
		printf("%d\n", tm->value);
		tm = tm->next;
	}
	
	free_all_stacks(&stack_a, &stack_b);
	free_pointers(data.array, &data.sorted_numbers,
		&data.original_numbers, data.count);
	return (0);
}

int	main(int argc, char **argv)
{
	push_swap(argc, argv);
}

===== push_to_b.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_to_b.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 15:18:55 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:17:52 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	set_max_range(int count)
{
	if (count <= 10)
		return (5);
	if (count <= 100)
		return (16);
	return (32);
}

void	push_to_b(t_stack_node **stack_a, t_stack_node **stack_b, int c)
{
	int				min_range;
	int				max_range;

	min_range = 0;
	max_range = set_max_range(c);
	while (*stack_a)
	{
		if ((*stack_a)->index <= min_range)
		{
			pb(stack_a, stack_b, *stack_a, 1);
			min_range++;
		}
		else if ((*stack_a)->index <= min_range + max_range)
		{
			pb(stack_a, stack_b, *stack_a, 1);
			rb(stack_b, 1);
			min_range++;
		}
		else
			ra(stack_a, 1);
	}
}

===== reverse_rotate.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   reverse_rotate.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 17:01:27 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:39:55 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	reverse_rotate(t_stack_node **stack)
{
	t_stack_node	*last;
	t_stack_node	*prev;

	if (stack && *stack && (*stack)->next)
	{
		prev = NULL;
		last = *stack;
		while (last->next)
		{
			prev = last;
			last = last->next;
		}
		prev->next = NULL;
		last->next = *stack;
		*stack = last;
	}
}


void	rra(t_stack_node **stack_a, int to_print)
{
	if(to_print)
		ft_print("rra");
	reverse_rotate(stack_a);
}

void	rrb(t_stack_node **stack_b, int to_print)
{
	if(to_print)
		ft_print("rrb");
	reverse_rotate(stack_b);
}

void rrr(t_stack_node **a, t_stack_node **b, int print)
{
    rra(a, 0);
    rrb(b, 0);
    if (print)
        ft_print("rrr");
}

===== rotate.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   rotate.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 17:00:46 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:39:57 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	rotate(t_stack_node **stack)
{
	t_stack_node	*temp;
	t_stack_node	*search;

	if (stack && *stack && (*stack)->next)
	{
		temp = *stack;
		*stack = temp->next;
		temp->next = NULL;
		search = *stack;
		while (search->next)
			search = search->next;
		search->next = temp;
	}
}

void	ra(t_stack_node **stack_a, int to_print)
{
	if(to_print)
		ft_print("ra");
	rotate(stack_a);
}

void	rb(t_stack_node **stack_b, int to_print)
{
	if(to_print)
		ft_print("rb");
	rotate(stack_b);
}

void rr(t_stack_node **a, t_stack_node **b, int print)
{
    ra(a, 0);
    rb(b, 0);
    if (print)
        ft_print("rr");
}

===== split_them.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   split_them.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/24 16:37:25 by brouane           #+#    #+#             */
/*   Updated: 2026/01/24 21:18:58 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

char	*ft_putword(char *word, char const *s, int i, int word_len)
{
	int	j;

	j = 0;
	while (word_len > 0)
	{
		word[j] = s[i - word_len];
		j++;
		word_len--;
	}
	word[j] = '\0';
	return (word);
}

int	ft_split_words(char const *s, char ***s2, int num_words, int word)
{
	int	i;
	int	word_len;
	int	reached_index;

	i = 0;
	reached_index = 0;
	while (reached_index < num_words)
	{
		word_len = 0;
		while (s[i] && s[i] == 32)
			i++;
		while (s[i] && s[i] != 32)
		{
			i++;
			word_len++;
		}
		(*s2)[word] = (char *)malloc(sizeof(char) * (word_len + 1));
		if (!(*s2)[word])
			return (free_array(*s2, word), -1);
		ft_putword((*s2)[word], s, i, word_len);
		reached_index++;
		word++;
	}
	(*s2)[word] = NULL;
	return (word);
}

int	split_them(char const *s, char ***s2, int word)
{
	unsigned int	num_words;
	int				index_reached;

	num_words = ft_count_words(s, 32);
	index_reached = ft_split_words(s, s2, num_words, word);
	return (index_reached);
}

===== swap.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   swap.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/03 21:36:37 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:40:01 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	swap(t_stack_node **stack)
{
	t_stack_node	*temp;

	temp = *stack;
	*stack = (*stack)->next;
	temp->next = (*stack)->next;
	(*stack)->next = temp;
}

void	sa(t_stack_node **stack_a, int to_print)
{
	if(to_print)
		ft_print("sa");
	swap(stack_a);
}

void	sb(t_stack_node **stack_b, int to_print)
{
	if(to_print)
		ft_print("sb");
	swap(stack_b);
}

void ss(t_stack_node **a, t_stack_node **b, int print)
{
    sa(a, 0);
    sb(b, 0);
    if (print)
        ft_print("ss");
}
===== three_sorter.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   three_sorter.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/20 18:13:03 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:17:14 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	three_sorter_cases(t_stack_node **stack_a, int a, int b, int c)
{
	if (a > b && b < c && a < c)
		sa(stack_a, 1);
	else if (a > b && b > c)
	{
		sa(stack_a, 1);
		rra(stack_a, 1);
	}
	else if (a > b && b < c && a > c)
		ra(stack_a, 1);
	else if (a < b && b > c && a < c)
	{
		sa(stack_a, 1);
		ra(stack_a, 1);
	}
	else if (a < b && b > c && a > c)
		rra(stack_a, 1);
}

void	three_sorter(t_stack_node **stack_a)
{
	t_stack_node	*second;
	t_stack_node	*third;
	int				a;
	int				b;
	int				c;

	second = (*stack_a)->next;
	third = second->next;
	a = (*stack_a)->index;
	b = second->index;
	c = third->index;
	three_sorter_cases(stack_a, a, b, c);
}

===== checker.h =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checker.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/01/31 20:50:43 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:50:44 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CHECKER_H
# define CHECKER_H

# include <stdlib.h>
# include <unistd.h>
# include <limits.h>

# include "push_swap.h"
# include "get_next_line.h"

/* ===== STRING ===== */
int     ft_strcmp(char *s1, char *s2);

/* ===== DOUBLE OPS ===== */
void    ss(t_stack_node **a, t_stack_node **b, int print);
void    rr(t_stack_node **a, t_stack_node **b, int print);
void    rrr(t_stack_node **a, t_stack_node **b, int print);

#endif

===== get_next_line.h =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/18 11:39:55 by brouane          #+#    #+#             */
/*   Updated: 2025/12/03 17:47:15 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# include <stdlib.h>
# include <unistd.h>

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 10
# endif

char	*get_next_line(int fd);
size_t	ft_strlen(const char *str);
char	*ft_strjoin(char *working_line, char *buffer);
char	*next_line(char *working_line);
char	*new_line(char *working_line);
char	*read_line(char *working_line, int fd);
int		ft_strchr(char *working_line);

#endif

===== push_swap.h =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/24 16:49:59 by brouane           #+#    #+#             */
/*   Updated: 2026/01/31 20:57:08 by brouane          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H

# include <stdio.h>




# include <unistd.h>
# include <stdlib.h>
# include <limits.h>

typedef struct s_stack_node
{
	int					value;
	int					index;
	struct s_stack_node	*next;
}	t_stack_node;

typedef struct s_data
{
	char	**array;
	long	*original_numbers;
	long	*sorted_numbers;
	int		count;
}	t_data;

int	initialize_data(int argc, char **argv, t_data *data);


int				check_for_errors(char ***array, long **sorted_numbers, int count);
int				ft_count_words(char const *str, char count);
int				find_index(int value, long *sorted_numbers, int count);
size_t			ft_strlen(const char *s);
int				free_array(char **ptr, int i);
void			free_pointers(char **array, long **sorted_numbers,
					long **original_numbers, int len);
void			free_stack(t_stack_node **stack);
void			free_all_stacks(t_stack_node **stack_a, t_stack_node **stack_b);
int			ft_atoi(const char *nptr, int *flag);
int				ft_lstadd_back(t_stack_node **lst, long value, int index);
void			ft_print(char *str);
void	ra(t_stack_node **stack_a, int to_print);
void	rb(t_stack_node **stack_b, int to_print);
void	rra(t_stack_node **stack_a, int to_print);
void	rrb(t_stack_node **stack_b, int to_print);
void	pb(t_stack_node **stack_a, t_stack_node **stack_b,
					t_stack_node *to_push, int to_print);
void	pa(t_stack_node **stack_a, t_stack_node **stack_b,
					t_stack_node *to_push, int to_print);
void	sa(t_stack_node **stack_a, int to_print);
void	sb(t_stack_node **stack_b, int to_print);
void    ss(t_stack_node **a, t_stack_node **b, int print);
void    rr(t_stack_node **a, t_stack_node **b, int print);
void    rrr(t_stack_node **a, t_stack_node **b, int print);
int				count_all_nums(char **argv, int argc);
char			**array_manager(char **argv, int argc, int count);
void			numbers_manager(char ***array, int count,
					long **sorted_numbers, long **original_numbers);
void			numbers_copy(long *sorted_numbers, long *original_numbers, int count);
int				sort_numbers(long *sorted_numbers, int count);
int				assign_to_stack(t_stack_node **stack,
					long *original_numbers, long *sorted_numbers, int count);
void			operations_manager(t_stack_node **stack_a,
					t_stack_node **stack_b, int count);
void			three_sorter(t_stack_node **stack_a);
void			push_back_to_a(t_stack_node **stack_a,
					t_stack_node **stack_b, int count);
void			push_from_a(t_stack_node **stack_a,
					t_stack_node **stack_b, int count);
void			push_to_b(t_stack_node **stack_a,
					t_stack_node **stack_b, int count);
int				split_them(char const *s, char ***s2, int word);

#endif

===== Makefile =====
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: brouane <brouane@student.1337.ma>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2026/01/08 21:41:29 by brouane           #+#    #+#              #
#    Updated: 2026/01/31 20:52:16 by brouane          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# NAME    = push_swap

# CC      = cc
# CFLAGS  = -Wall -Wextra -Werror
# RM      = rm -f

# SRCS	= ft_atoi.c \
# 		  error_checker.c \
# 		  extended_functions.c \
# 		  external_functions.c \
# 		  freedom.c \
# 		  ft_lstadd_back.c \
# 		  ft_print.c \
# 		  internal_functions.c \
# 		  operations_manager.c \
# 		  push.c \
# 		  push_back_to_a.c \
# 		  push_from_a.c \
# 		  push_to_b.c \
# 		  push_swap.c \
# 		  rotate.c \
# 		  reverse_rotate.c \
# 		  split_them.c \
# 		  swap.c \
# 		  three_sorter.c


# OBJS    = $(SRCS:.c=.o)

# all: $(NAME)

# $(NAME): $(OBJS)
# 	$(CC) $(OBJS) -o $(NAME)

# %.o: %.c push_swap.h
# 	$(CC) $(CFLAGS) -c $< -o $@

# clean:
# 	$(RM) $(OBJS)

# fclean: clean
# 	$(RM) $(NAME)

# re: fclean all

# .PHONY: all clean fclean re





NAME = checker

CC = cc
CFLAGS = -Wall -Wextra -Werror

SRC = checker.c error_checker.c extended_functions.c \
      external_functions.c freedom.c ft_atoi.c \
      ft_lstadd_back.c ft_print.c internal_functions.c \
      push.c rotate.c reverse_rotate.c swap.c \
      split_them.c \
      get_next_line.c get_next_line_utils.c


OBJ = $(SRC:.c=.o)

all: $(NAME)

$(NAME): $(OBJ)
	$(CC) $(CFLAGS) $(OBJ) -o $(NAME)

clean:
	rm -f $(OBJ)

fclean: clean
	rm -f $(NAME)

re: fclean all

